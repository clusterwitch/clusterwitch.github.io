# Resume-Tailoring AI Tool on Eleventy + GitHub Pages
## Complete Project Plan

---

## A. Folder Structure for 11ty Project

```
clusterwitch.github.io/
├── .eleventy.js                 # 11ty config
├── .github/
│   └── workflows/
│       └── deploy.yml           # GitHub Pages deployment
├── src/
│   ├── _includes/
│   │   ├── header.njk           # Site header component
│   │   ├── footer.njk           # Site footer component
│   │   └── layout.njk           # Main layout wrapper
│   ├── _data/
│   │   └── site.json            # Site metadata
│   ├── assets/
│   │   ├── css/
│   │   │   └── style.css        # Global styles (minimal)
│   │   └── images/
│   │       └── (portfolio images, etc.)
│   ├── js/
│   │   ├── lib/
│   │   │   ├── fileUpload.js    # Handle file inputs
│   │   │   ├── pdfParser.js     # Parse PDFs with pdf.js
│   │   │   ├── templateMerge.js # Merge data into template
│   │   │   ├── aiCall.js        # Send prompt to AI API
│   │   │   ├── markdownRender.js# Render MD with marked.js
│   │   │   └── pdfExport.js     # Export to PDF
│   │   └── tool.js              # Main tool orchestrator
│   ├── pages/
│   │   ├── index.md             # Home/portfolio page
│   │   ├── tool.njk             # Resume-tailor tool page
│   │   └── about.md             # About page (optional)
│   └── templates/
│       └── (example templates for users to upload)
├── package.json
├── .gitignore
└── README.md

# Output folder (generated by 11ty):
_site/                           # Never commit; GitHub Pages reads this
├── index.html
├── tool/index.html
├── about/index.html
├── assets/
│   ├── css/
│   ├── images/
│   └── js/
│       ├── lib/
│       └── tool.js
└── templates/
```

---

## B. Eleventy Content Pipeline vs. Client-Side Code

### Files in the 11ty Pipeline (Server-Build Time)
These are processed by 11ty and become static HTML/CSS:
- `.md` files in `src/pages/` → converted to HTML pages
- `.njk` files in `src/pages/` → rendered as HTML using templates
- `src/_includes/*.njk` → reusable template components
- `src/_data/*.json` → accessible as global data in templates
- Static assets in `src/assets/` → copied as-is to `_site/`

### Files that Run Client-Side (Browser Runtime)
These are served as-is and execute in the browser after page load:
- `src/js/lib/*.js` — utility modules (never bundled or transpiled in this plan)
- `src/js/tool.js` — main application orchestrator
- Third-party libraries loaded via CDN (pdf.js, marked.js, etc.)

**Key Decision:** All JavaScript runs at runtime on the client. No build step for JS (no Webpack, Rollup, etc.). Modules are simple ES6 modules loaded dynamically.

---

## C. Required Client-Side Libraries

### 1. **PDF Parsing**
- **pdf.js** (Mozilla's official PDF parser)
  - CDN: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.14.159/pdf.min.js`
  - Worker: `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.14.159/pdf.worker.min.js`

### 2. **Markdown Rendering**
- **marked.js** (lightweight, no dependencies)
  - CDN: `https://cdn.jsdelivr.net/npm/marked/marked.min.js`

### 3. **PDF Export (Client-Side)**
- **html2pdf.js** (converts HTML to PDF in browser)
  - CDN: `https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js`
  - OR use browser's native `window.print()` for simpler approach

### 4. **JSON Parsing**
- Built-in: `JSON.parse()` (no library needed)

### Summary
```json
{
  "dependencies": {
    "pdf.js": "3.14.159",
    "marked.js": "latest",
    "html2pdf.js": "0.10.1"
  },
  "note": "All loaded via CDN; no npm install required for client libs"
}
```

---

## D. Client-Side App Architecture

### Data Flow
```
User Inputs
    ↓
[fileUpload.js] ← reads files from <input>
    ↓
[pdfParser.js] ← parses job desc PDF if needed
[JSON.parse] ← parses resume.json natively
[marked.js] ← parses markdown templates
    ↓
[templateMerge.js] ← builds combined prompt text
    ↓
[aiCall.js] ← POST to AI API endpoint (OpenAI, Claude, etc.)
    ↓
AI Response (tailored resume markdown)
    ↓
[markdownRender.js] ← renders with marked.js into HTML
    ↓
User sees preview in browser
    ↓
[pdfExport.js] ← user clicks "Export PDF"
    ↓
PDF file downloaded to user's machine
```

### State Management
- Store in a single `app` object:
  ```javascript
  const app = {
    jobDescription: "",        // raw text from PDF or textarea
    resume: {},                // parsed JSON object
    outputTemplate: "",        // markdown template text
    aiPrompt: "",              // markdown template with placeholders
    aiResponse: "",            // markdown output from AI
    tailoredHtml: "",          // rendered HTML from markdown
  };
  ```

### Module Responsibilities
1. **fileUpload.js** — attach listeners to file inputs; call parsers
2. **pdfParser.js** — use pdf.js to extract text from PDF blobs
3. **templateMerge.js** — interpolate variables into AI prompt template
4. **aiCall.js** — build fetch() request, send to API, handle errors
5. **markdownRender.js** — render markdown using marked.js
6. **pdfExport.js** — either use html2pdf.js or window.print()
7. **tool.js** — orchestrate all modules, manage app state, handle UI events

---

## E. HTML Structure for the Tool Page

File: `src/pages/tool.njk`

```html
---
layout: layout.njk
title: Resume Tailor
---

<div class="tool-container">
  <h1>Resume Tailor</h1>
  <p>Upload or paste your job description, resume, and templates. The tool will use AI to tailor your resume.</p>

  <section class="tool-inputs">
    <fieldset>
      <legend>Job Description</legend>
      <div>
        <label>
          <input type="file" id="jobDescFile" accept=".pdf,.txt" />
          Upload PDF or TXT
        </label>
      </div>
      <div>
        <label>Or paste:</label>
        <textarea id="jobDescText" placeholder="Paste job description here..."></textarea>
      </div>
    </fieldset>

    <fieldset>
      <legend>Resume (JSON)</legend>
      <label>
        <input type="file" id="resumeFile" accept=".json" />
        Upload resume.json
      </label>
    </fieldset>

    <fieldset>
      <legend>Output Template (Markdown)</legend>
      <label>
        <input type="file" id="outputTemplateFile" accept=".md,.txt" />
        Upload output_template.md
      </label>
    </fieldset>

    <fieldset>
      <legend>AI Prompt (Markdown)</legend>
      <label>
        <input type="file" id="aiPromptFile" accept=".md,.txt" />
        Upload ai_prompt.md
      </label>
    </fieldset>

    <fieldset>
      <legend>AI Configuration</legend>
      <div>
        <label>
          API Key (stored in browser memory, never sent to server):
          <input type="password" id="apiKey" placeholder="sk-..." />
        </label>
      </div>
      <div>
        <label>
          API Provider:
          <select id="apiProvider">
            <option value="openai">OpenAI (GPT-4)</option>
            <option value="anthropic">Anthropic (Claude)</option>
          </select>
        </label>
      </div>
    </fieldset>

    <button id="generateBtn" type="button">Generate Tailored Resume</button>
  </section>

  <section class="tool-output">
    <div class="preview">
      <h2>Preview</h2>
      <div id="previewContent" contenteditable="true"></div>
    </div>

    <div class="actions">
      <button id="copyBtn" type="button">Copy to Clipboard</button>
      <button id="exportPdfBtn" type="button">Export as PDF</button>
      <button id="printBtn" type="button">Print</button>
    </div>
  </section>

  <section class="logs">
    <details>
      <summary>Debug Output</summary>
      <pre id="debugLog"></pre>
    </details>
  </section>
</div>

<script src="/assets/js/lib/fileUpload.js" type="module"></script>
<script src="/assets/js/lib/pdfParser.js" type="module"></script>
<script src="/assets/js/lib/templateMerge.js" type="module"></script>
<script src="/assets/js/lib/aiCall.js" type="module"></script>
<script src="/assets/js/lib/markdownRender.js" type="module"></script>
<script src="/assets/js/lib/pdfExport.js" type="module"></script>
<script src="/assets/js/tool.js" type="module"></script>
```

---

## F. JavaScript Modules Needed

### 1. **fileUpload.js**
- Attach change listeners to file inputs
- Read files as text or blob
- Emit events for other modules to handle

### 2. **pdfParser.js**
- Use pdf.js to extract text from PDF blob
- Return promise that resolves to extracted text

### 3. **templateMerge.js**
- Take ai_prompt.md (template with `{{placeholders}}`)
- Substitute placeholders with values from resume.json and job description
- Return merged prompt text

### 4. **aiCall.js**
- Build prompt text from merged template
- POST to OpenAI or Anthropic API endpoint
- Include API key from user input
- Return promise that resolves to response text

### 5. **markdownRender.js**
- Use marked.js to render markdown to HTML
- Return HTML string
- Handle special rendering options (sanitize, line breaks)

### 6. **pdfExport.js**
- Take rendered HTML content
- Either use html2pdf.js or trigger browser print dialog
- Trigger download/print

### 7. **tool.js** (Orchestrator)
- Import all modules
- Manage global app state
- Wire up button click handlers
- Call modules in correct sequence
- Update UI as data flows through

---

## G. Minimal but Functional Example of Each JS Module

### fileUpload.js
```javascript
export const setupFileInputs = () => {
  const jobDescFile = document.getElementById('jobDescFile');
  const resumeFile = document.getElementById('resumeFile');
  const outputTemplateFile = document.getElementById('outputTemplateFile');
  const aiPromptFile = document.getElementById('aiPromptFile');

  jobDescFile.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (file.type === 'application/pdf') {
      const text = await window.app.parsePdf(file);
      window.app.jobDescription = text;
    } else {
      const text = await file.text();
      window.app.jobDescription = text;
    }
    window.app.log(`Job description loaded: ${window.app.jobDescription.length} chars`);
  });

  resumeFile.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    const text = await file.text();
    window.app.resume = JSON.parse(text);
    window.app.log(`Resume loaded: ${Object.keys(window.app.resume).length} keys`);
  });

  outputTemplateFile.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    window.app.outputTemplate = await file.text();
    window.app.log(`Output template loaded: ${window.app.outputTemplate.length} chars`);
  });

  aiPromptFile.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    window.app.aiPrompt = await file.text();
    window.app.log(`AI prompt loaded: ${window.app.aiPrompt.length} chars`);
  });
};
```

### pdfParser.js
```javascript
// Set worker for pdf.js
pdfjsLib.GlobalWorkerOptions.workerSrc = 
  'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.14.159/pdf.worker.min.js';

export const parsePdf = async (blob) => {
  const arrayBuffer = await blob.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
  let text = '';

  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += content.items.map(item => item.str).join(' ') + '\n';
  }

  return text;
};
```

### templateMerge.js
```javascript
export const buildPrompt = (
  aiPromptTemplate,
  resumeJson,
  jobDescription,
  outputTemplate
) => {
  let prompt = aiPromptTemplate;

  // Replace {{resume}} with stringified JSON
  prompt = prompt.replace('{{resume}}', JSON.stringify(resumeJson, null, 2));

  // Replace {{job_description}} with job text
  prompt = prompt.replace('{{job_description}}', jobDescription);

  // Replace {{output_template}} with template markdown
  prompt = prompt.replace('{{output_template}}', outputTemplate);

  return prompt;
};
```

### aiCall.js
```javascript
export const callAiApi = async (prompt, apiKey, provider) => {
  if (provider === 'openai') {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4',
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.7,
        max_tokens: 2000,
      }),
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.choices[0].message.content;
  }

  if (provider === 'anthropic') {
    const response = await fetch('https://api.anthropic.com/v1/messages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'x-api-key': apiKey,
        'anthropic-version': '2023-06-01',
      },
      body: JSON.stringify({
        model: 'claude-3-sonnet-20240229',
        max_tokens: 2000,
        messages: [{ role: 'user', content: prompt }],
      }),
    });

    if (!response.ok) {
      throw new Error(`API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json();
    return data.content[0].text;
  }

  throw new Error('Unknown provider');
};
```

### markdownRender.js
```javascript
export const renderMarkdown = (markdown) => {
  // marked.js is loaded globally via CDN
  const html = marked.parse(markdown, {
    breaks: true,
    gfm: true,
  });
  return html;
};
```

### pdfExport.js
```javascript
export const exportPdf = async (htmlContent, filename = 'resume.pdf') => {
  const element = document.createElement('div');
  element.innerHTML = htmlContent;

  // If html2pdf.js is loaded, use it
  if (typeof html2pdf !== 'undefined') {
    const opt = {
      margin: 10,
      filename: filename,
      image: { type: 'jpeg', quality: 0.98 },
      html2canvas: { scale: 2 },
      jsPDF: { orientation: 'portrait', unit: 'mm', format: 'a4' },
    };
    await html2pdf().set(opt).from(element).save();
  } else {
    // Fallback: use browser print dialog
    const printWindow = window.open('', '', 'width=800,height=600');
    printWindow.document.write(`
      <!DOCTYPE html>
      <html>
      <head><title>${filename}</title></head>
      <body>${htmlContent}</body>
      </html>
    `);
    printWindow.document.close();
    printWindow.print();
  }
};
```

### tool.js (Orchestrator)
```javascript
import { setupFileInputs } from './lib/fileUpload.js';
import { parsePdf } from './lib/pdfParser.js';
import { buildPrompt } from './lib/templateMerge.js';
import { callAiApi } from './lib/aiCall.js';
import { renderMarkdown } from './lib/markdownRender.js';
import { exportPdf } from './lib/pdfExport.js';

// Initialize global app state
window.app = {
  jobDescription: '',
  resume: {},
  outputTemplate: '',
  aiPrompt: '',
  aiResponse: '',
  tailoredHtml: '',
  logs: [],

  async parsePdf(blob) {
    return await parsePdf(blob);
  },

  log(message) {
    this.logs.push(message);
    document.getElementById('debugLog').textContent += message + '\n';
    console.log(message);
  },
};

// Setup file inputs
setupFileInputs();

// Generate button
document.getElementById('generateBtn').addEventListener('click', async () => {
  try {
    window.app.log('Starting AI generation...');

    const apiKey = document.getElementById('apiKey').value;
    const provider = document.getElementById('apiProvider').value;

    if (!apiKey) {
      throw new Error('API key required');
    }

    const prompt = buildPrompt(
      window.app.aiPrompt,
      window.app.resume,
      window.app.jobDescription,
      window.app.outputTemplate
    );

    window.app.log('Sending prompt to AI API...');
    const response = await callAiApi(prompt, apiKey, provider);

    window.app.aiResponse = response;
    window.app.log('AI response received');

    const html = renderMarkdown(response);
    window.app.tailoredHtml = html;

    document.getElementById('previewContent').innerHTML = html;
    window.app.log('Preview rendered');
  } catch (error) {
    window.app.log(`ERROR: ${error.message}`);
    alert(`Error: ${error.message}`);
  }
});

// Export PDF button
document.getElementById('exportPdfBtn').addEventListener('click', async () => {
  if (!window.app.tailoredHtml) {
    alert('No preview to export. Generate a tailored resume first.');
    return;
  }
  await exportPdf(window.app.tailoredHtml, 'tailored-resume.pdf');
  window.app.log('PDF exported');
});

// Copy button
document.getElementById('copyBtn').addEventListener('click', () => {
  const text = window.app.aiResponse;
  navigator.clipboard.writeText(text).then(() => {
    window.app.log('Markdown copied to clipboard');
    alert('Copied to clipboard!');
  });
});

// Print button
document.getElementById('printBtn').addEventListener('click', () => {
  window.print();
  window.app.log('Print dialog opened');
});

window.app.log('Tool initialized');
```

---

## H. Deployment to GitHub Pages

### Step 1: Configure 11ty for GitHub Pages

File: `.eleventy.js`

```javascript
module.exports = function(eleventyConfig) {
  // Copy static assets
  eleventyConfig.addPassthroughCopy("src/assets");
  eleventyConfig.addPassthroughCopy("src/templates");

  // Watch Sass if used
  eleventyConfig.setWatchThrottleWaitTime(100);

  return {
    dir: {
      input: "src",
      output: "_site",
      includes: "_includes",
      layouts: "_includes",
      data: "_data",
    },
    markdownTemplateEngine: "njk",
    htmlTemplateEngine: "njk",
  };
};
```

### Step 2: Package.json

```json
{
  "name": "clusterwitch.github.io",
  "version": "1.0.0",
  "description": "Portfolio + Resume Tailor Tool",
  "scripts": {
    "build": "eleventy",
    "serve": "eleventy --serve",
    "watch": "eleventy --watch",
    "deploy": "npm run build && git add _site && git commit -m 'Deploy' && git push"
  },
  "devDependencies": {
    "@11ty/eleventy": "^2.0.0"
  }
}
```

### Step 3: GitHub Actions Workflow

File: `.github/workflows/deploy.yml`

```yaml
name: Build and Deploy

on:
  push:
    branches: [main]

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm install

      - name: Build site
        run: npm run build

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./_site
```

### Step 4: Repository Settings

1. Go to **Settings → Pages**
2. Set **Source** to `gh-pages` branch
3. GitHub Actions will automatically build and deploy on each push to `main`

### Step 5: Local Development

```bash
# Install dependencies
npm install

# Serve locally with live reload
npm run serve

# Build static site
npm run build

# Watch for changes
npm run watch
```

Site will be available at `https://clusterwitch.github.io/`

---

## Summary Checklist

- [ ] Create 11ty config (`.eleventy.js`)
- [ ] Set up folder structure under `src/`
- [ ] Create portfolio pages (`index.md`, `about.md`)
- [ ] Create tool page (`tool.njk`) with HTML structure
- [ ] Create all 7 JS modules under `src/js/lib/`
- [ ] Create main orchestrator (`tool.js`)
- [ ] Add CDN links to HTML (pdf.js, marked.js, html2pdf.js)
- [ ] Set up GitHub Actions workflow
- [ ] Configure GitHub Pages settings
- [ ] Test locally with `npm run serve`
- [ ] Push to `main` branch; GitHub Actions deploys to `gh-pages`
- [ ] Verify site at `https://clusterwitch.github.io/`

---

## Example User Flow

1. User navigates to `https://clusterwitch.github.io/tool`
2. Uploads or pastes:
   - Job description (PDF or text)
   - Resume as JSON
   - Output template as Markdown
   - AI prompt template as Markdown
3. Browser parses all files client-side (no server)
4. User enters API key (never leaves browser)
5. Clicks "Generate Tailored Resume"
6. JavaScript:
   - Extracts text from PDF (pdf.js)
   - Builds combined prompt (templateMerge.js)
   - POSTs to OpenAI or Anthropic (aiCall.js)
   - Receives tailored resume markdown
   - Renders to HTML (marked.js)
   - Displays in preview
7. User edits preview directly in contenteditable div
8. Clicks "Export PDF" or "Print"
9. PDF is generated (html2pdf.js or browser print dialog)
10. File downloads to user's machine
11. API key never stored, never sent to any backend

---

## Key Principles

✓ **100% Client-Side** — No backend, no server, no Python  
✓ **No Build Step** — Plain ES6 modules, loaded via `<script type="module">`  
✓ **No Package Dependencies** — Libraries from CDN  
✓ **Static Site** — Eleventy generates HTML; deploy to GitHub Pages  
✓ **Privacy-First** — API keys stay in browser; never logged or sent anywhere  
✓ **Deterministic** — No randomness in architecture or data flow  
✓ **Minimal CSS** — Focus on function, not aesthetics  

---

End of plan.
